"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[187],{50268:function(e){e.exports=JSON.parse('{"functions":[{"name":"CombineReducers","desc":"","params":[{"name":"ReducersMap","desc":"The reducers map","lua_type":"{[Key: string]: ReducerFunction}"}],"returns":[{"desc":"A function that iterates through all the reducers and calls their respect GetState and SetState functions.","lua_type":"ReducerFunction"}],"function_type":"static","tags":["Utility"],"source":{"line":16,"path":"src/CombineReducers/init.lua"}},{"name":"CreateStore","desc":"This is a shorthand for `Helium.Store.new`.","params":[{"name":"Reducer","desc":"The reducer function.","lua_type":"ReducerFunction"},{"name":"InitialState","desc":"The initial state.","lua_type":"NonNil"}],"returns":[{"desc":"","lua_type":"Store"}],"function_type":"static","tags":["Shorthand","Utility"],"source":{"line":57,"path":"src/init.lua"}},{"name":"SetGlobalConfiguration","desc":"This function is used to set the configuration of how Helium behaves.","params":[{"name":"ConfigurationValues","desc":"The new configuration.","lua_type":"HeliumConfiguration"}],"returns":[],"function_type":"static","tags":["Configuration","Utility"],"source":{"line":67,"path":"src/init.lua"}},{"name":"SetGlobalConfig","desc":"This is a shorthand for `Helium.SetGlobalConfiguration`.","params":[{"name":"ConfigurationValues","desc":"The new configuration.","lua_type":"HeliumConfiguration"}],"returns":[],"function_type":"static","tags":["Configuration","Shorthand","Utility"],"source":{"line":77,"path":"src/init.lua"}},{"name":"SetConfiguration","desc":"This is a shorthand for `Helium.SetGlobalConfiguration`.","params":[{"name":"ConfigurationValues","desc":"The new configuration.","lua_type":"HeliumConfiguration"}],"returns":[],"function_type":"static","tags":["Configuration","Shorthand","Utility"],"source":{"line":87,"path":"src/init.lua"}},{"name":"SetConfig","desc":"This is a shorthand for `Helium.SetGlobalConfiguration`.","params":[{"name":"ConfigurationValues","desc":"The new configuration.","lua_type":"HeliumConfiguration"}],"returns":[],"function_type":"static","tags":["Configuration","Shorthand","Utility"],"source":{"line":97,"path":"src/init.lua"}},{"name":"InspectorMiddleware","desc":"Prints out the whole action being dispatched.\\n\\n```lua\\nlocal AwesomeAction = Helium.MakeActionCreator(\\"AwesomeAction\\", function(ObjectName: string, IsAwesome: boolean)\\n\\treturn {\\n\\t\\tObjectName = ObjectName;\\n\\t\\tIsAwesome = IsAwesome;\\n\\t}\\nend)\\n\\nlocal Store = Helium.Store.new(function(Action, _, SetState)\\n\\tif Action.Type == AwesomeAction.ActionName then\\n\\t\\tSetState(Action.ObjectName, Action.IsAwesome)\\n\\tend\\nend, {\\n\\tLPlus = false;\\n\\tLPlusLight = false;\\n\\tHelium = false;\\n}):ApplyMiddleware(Helium.InspectorMiddleware)\\n\\nStore:Fire(AwesomeAction(\\"LPlus\\", true))\\n--[[\\n\\tPrints:\\n\\t\\t{\\n\\t\\t\\tType = \\"AwesomeAction\\";\\n\\t\\t\\tObjectName = \\"LPlus\\";\\n\\t\\t\\tIsAwesome = true;\\n\\t\\t}\\n]]\\n```","params":[],"returns":[{"desc":"The handler code for the middleware.","lua_type":"MiddlewareHandler"}],"function_type":"static","tags":["Middleware"],"source":{"line":135,"path":"src/init.lua"}},{"name":"LoggerMiddleware","desc":"Prints out the action types of every action dispatched.\\n\\n```lua\\nlocal AwesomeAction = Helium.MakeActionCreator(\\"AwesomeAction\\", function(ObjectName: string, IsAwesome: boolean)\\n\\treturn {\\n\\t\\tObjectName = ObjectName;\\n\\t\\tIsAwesome = IsAwesome;\\n\\t}\\nend)\\n\\nlocal Store = Helium.Store.new(function(Action, _, SetState)\\n\\tif Action.Type == AwesomeAction.ActionName then\\n\\t\\tSetState(Action.ObjectName, Action.IsAwesome)\\n\\tend\\nend, {\\n\\tLPlus = false;\\n\\tLPlusLight = false;\\n\\tHelium = false;\\n}):ApplyMiddleware(Helium.InspectorMiddleware)\\n\\nStore:Fire(AwesomeAction(\\"LPlus\\", true)) -- Prints: \\"AwesomeAction\\"\\n```","params":[],"returns":[{"desc":"The handler code for the middleware.","lua_type":"MiddlewareHandler"}],"function_type":"static","tags":["Middleware"],"source":{"line":164,"path":"src/init.lua"}},{"name":"SpunkMiddleware","desc":"Like `ThunkMiddleware`, allows functions to be dispatched. The only difference is that the functions being dispatched will be spawned\\nimmediately in a separate thread. This could be more ideal for Roblox development as opposed to JavaScript do to the lack of Promise objects.\\n\\n```lua\\nlocal function FetchCoins()\\n\\treturn function(Dispatch, GetState)\\n\\t\\t-- Where we would normally return an action here, we instead return a spawned thunk that defers our change in state.\\n\\t\\tlocal Coins = ReplicatedStorage.GetCoins:InvokeServer()\\n\\t\\tDispatch({\\n\\t\\t\\tType = \\"SetCoins\\";\\n\\t\\t\\tValue = Coins;\\n\\t\\t})\\n\\tend\\nend\\n\\nlocal Store = Helium.Store.new(function(Action, _, SetState)\\n\\tif Action.Type == \\"SetCoins\\" then\\n\\t\\tSetState(\\"Coins\\", Action.Value)\\n\\tend\\nend, InitialState):ApplyMiddleware(Helium.SpunkMiddleware)\\n\\nStore:Fire(FetchCoins())\\n```","params":[{"name":"Store","desc":"The Store of the middleware.","lua_type":"Store"}],"returns":[{"desc":"The handler code for the middleware.","lua_type":"MiddlewareHandler"}],"function_type":"static","tags":["Middleware"],"source":{"line":195,"path":"src/init.lua"}},{"name":"ThunkMiddleware","desc":"Like its Redux counterpart, thunk middleware allows functions to be dispatched as regular actions. When a function is encountered\\nby the middleware in place of an action, that function will be intercepted and called with the arguments `MyThunk(Dispatch, GetState)`.\\n\\n```lua\\nlocal function AddCoins()\\n\\treturn function(Dispatch, GetState)\\n\\t\\tDispatch({\\n\\t\\t\\tType = \\"SetCoins\\";\\n\\t\\t\\tValue = math.random(100);\\n\\t\\t})\\n\\tend\\nend\\n\\nlocal Store = Helium.Store.new(function(Action, _, SetState)\\n\\tif Action.Type == \\"SetCoins\\" then\\n\\t\\tSetState(\\"Coins\\", Action.Value)\\n\\tend\\nend, InitialState):ApplyMiddleware(Helium.ThunkMiddleware)\\n\\nStore:Fire(AddCoins())\\n```","params":[{"name":"Store","desc":"The Store of the middleware.","lua_type":"Store"}],"returns":[{"desc":"The handler code for the middleware.","lua_type":"MiddlewareHandler"}],"function_type":"static","tags":["Middleware"],"source":{"line":224,"path":"src/init.lua"}},{"name":"Make","desc":"This is a function similar to `Fusion.New` for creating Instances. While I don\'t personally suggest it,\\nit is here if you want to use it. The `Parent` property is always set last if it exists in the table.\\n\\n```lua\\nlocal Frame: Frame = Helium.Make(\\"Frame\\", {\\n\\tAnchorPoint = Vector2.new(0.5, 0.5);\\n\\tPosition = UDim2.fromScale(0.5, 0.5);\\n\\tSize = UDim2.fromOffset(140, 40);\\n\\n\\t[Helium.Children] = {\\n\\t\\tHelium.Make(\\"TextButton\\", {\\n\\t\\t\\tSize = UDim2.fromScale(1, 1);\\n\\t\\t\\tText = \\"Hello World!\\";\\n\\t\\t\\tActivated = function()\\n\\t\\t\\t\\tprint(\\"Button was activated!\\")\\n\\t\\t\\tend;\\n\\t\\t});\\n\\t};\\n})\\n\\nFrame:Destroy()\\n```","params":[{"name":"ClassName","desc":"The ClassName of the Instance you are creating.","lua_type":"T"},{"name":"Properties","desc":"The properties of the Instance you are creating.","lua_type":"{[string]: any, [Children]?: {Instance}},"}],"returns":[{"desc":"The created Instance.","lua_type":"Instance<T>"}],"function_type":"static","tags":["Utility"],"source":{"line":52,"path":"src/Make.lua"}},{"name":"MakeActionCreator","desc":"Action creators are helper objects that will generate actions from provided data and automatically populate the `Type` field.\\n\\nActions are structured in a way that they always have a `Type` field. They will often have some other values as well.\\n\\n```lua\\nlocal AwesomeAction = {\\n\\tType = \\"AwesomeAction\\";\\n\\n\\tArgumentName = \\"LPlus\\";\\n\\tIsAwesome = true;\\n}\\n```\\n\\nYou can generate an action from a function, but you must provide the `Type` field yourself.\\n\\n```lua\\nlocal function CreateAwesomeAction(ArgumentName: string, IsAwesome: boolean)\\n\\treturn {\\n\\t\\tType = \\"AwesomeAction\\";\\n\\n\\t\\tArgumentName = ArgumentName;\\n\\t\\tIsAwesome = IsAwesome;\\n\\t}\\nend\\n```\\n\\n`MakeActionCreator` is similar, but it will automatically populate the `Type` field using the first argument of the constructor function.\\n\\n```lua\\nlocal CreateAwesomeAction = Helium.MakeActionCreator(\\"AwesomeAction\\", function(ArgumentName: string, IsAwesome: boolean)\\n\\treturn {\\n\\t\\tArgumentName = ArgumentName;\\n\\t\\tIsAwesome = IsAwesome;\\n\\t}\\nend)\\n```\\n\\nThis can then be used in the Store reducer function.\\n\\n```lua\\nlocal CreateAwesomeAction = require(\\"CreateAwesomeAction\\")\\n\\nlocal Store = Helium.Store.new(function(Action, _, SetState)\\n\\tif Action.Type == CreateAwesomeAction.ActionName then\\n\\t\\tSetState(Action.ArgumentName, Action.IsAwesome)\\n\\tend\\nend, {\\n\\tLPlus = false;\\n\\tLPlusLight = false;\\n\\tHelium = false;\\n})\\n\\nStore:Fire(CreateAwesomeAction(\\"LPlus\\", true))\\nStore:Fire(CreateAwesomeAction(\\"Helium\\", true))\\nStore:Fire(CreateAwesomeAction(\\"LPlusLight\\", false))\\n\\nprint(Store:InspectState())\\n--[[\\n\\tPrints:\\n\\t\\t{\\n\\t\\t\\tHelium = true;\\n\\t\\t\\tLPlus = true;\\n\\t\\t\\tLPlusLight = false;\\n\\t\\t}\\n]]\\n```","params":[{"name":"ActionName","desc":"The name of the Action.","lua_type":"string"},{"name":"Function","desc":"The function that creates the action.","lua_type":"(...any) -> {[any]: any}"}],"returns":[{"desc":"The action creator.","lua_type":"ActionCreatorTable"}],"function_type":"static","tags":["Utility"],"source":{"line":99,"path":"src/MakeActionCreator.lua"}}],"properties":[{"name":"RedrawBinding","desc":"An [Enumerator](https://github.com/howmanysmall/enumerator/) Enum containing all of the RedrawBindings.\\n\\n:::info Case Change\\nTo keep consistent with the rest of the style of Helium, all the methods of Enumerator are PascalCase.\\n:::","lua_type":"RedrawBinding","tags":["Enums"],"readonly":true,"source":{"line":32,"path":"src/Enums.lua"}},{"name":"Store","desc":"This is the accessor for the `Store` object.\\n\\n```lua\\nlocal Store = Helium.Store.new(function() end, {})\\n```","lua_type":"Store","tags":["Class"],"source":{"line":236,"path":"src/init.lua"}},{"name":"Component","desc":"This is the accessor for the `Component` object.\\n\\n```lua\\nlocal Component = Helium.Component.Extend(\\"ComponentName\\")\\n```","lua_type":"Component","tags":["Class"],"source":{"line":248,"path":"src/init.lua"}},{"name":"Children","desc":"This is a Symbol used to indicate the children for an Instance created using `Helium.Make`.","lua_type":"ChildrenSymbol","tags":["Symbol"],"source":{"line":10,"path":"src/Make.lua"}}],"types":[{"name":"RedrawBinding","desc":"An Enum representing on which binding the Component will be redrawn on.","fields":[{"name":"Heartbeat","lua_type":"\\"Heartbeat\\"","desc":"Redraw on the next `Heartbeat` step."},{"name":"RenderStep","lua_type":"\\"RenderStep\\"","desc":"Redraw on the next `RenderStep` step."},{"name":"RenderStepTwice","lua_type":"\\"RenderStepTwice\\"","desc":"Redraw on two `RenderStep` steps."},{"name":"Stepped","lua_type":"\\"Stepped\\"","desc":"Redraw on the next `Stepped` step."}],"tags":["Enum"],"source":{"line":21,"path":"src/Enums.lua"}},{"name":"ReducerFunction","desc":"This is a function for reducing actions in the store.","lua_type":"(Action: BaseAction, GetState: (...any) -> any, SetState: (...any) -> ()) -> ()","source":{"line":32,"path":"src/init.lua"}},{"name":"HeliumConfiguration","desc":"This is the interface used for configuring how Helium behaves internally.","fields":[{"name":"ProfileRedraw","lua_type":"boolean?","desc":"Enables `debug.profilebegin` in the component redraw function."},{"name":"RunTypeChecking","lua_type":"boolean?","desc":"Enables type checking internally."},{"name":"SafeRedrawCheck","lua_type":"boolean?","desc":"Runs an `assert` check when `QueueRedraw` is called to validate that a component\'s RedrawBinding is correct."},{"name":"UseCombineReducersV2","lua_type":"boolean?","desc":"Enables using the V2 version of `CombineReducers`."},{"name":"UseSwitchStatementForQueueRedraw","lua_type":"boolean?","desc":"Enables using a switch statement for `QueueRedraw`. This won\'t be checked every `QueueRedraw` since performance is the goal here, only when `Component:Constructor` is called."}],"source":{"line":44,"path":"src/init.lua"}},{"name":"ActionBase","desc":"","fields":[{"name":"Type","lua_type":"string","desc":"The type of action."}],"source":{"line":13,"path":"src/MakeActionCreator.lua"}},{"name":"ActionCreatorTable","desc":"The ActionCreatorTable has a metatable with `__call`, so you can use it as a function. It returns an ActionBase.","fields":[{"name":"ActionName","lua_type":"string","desc":"The name of the action creator."},{"name":"Name","lua_type":"string","desc":"The name of the action creator."}],"source":{"line":22,"path":"src/MakeActionCreator.lua"}}],"name":"Helium","desc":"Helium is a library based on Rocrastinate with improvements for Luau as well as added features.\\n\\n:::info Rocrastinate\\nRocrastinate is a fantastic library that is unfortunatley not longer worked on. I\'ve taken development of it into my own hands to keep it alive as it does a lot of things extremely well.\\n:::","source":{"line":258,"path":"src/init.lua"}}')}}]);