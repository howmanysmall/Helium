[{"title":"Getting Started with Helium","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started with Helium Here are some quick links to get started using Helium: API DocsInstallation guideWhy use Helium?Why did I modify Rocrastinate?","keywords":""},{"title":"Why I modified Rocrastinate","type":0,"sectionRef":"#","url":"docs/WhyIModifiedRocrastinate","content":"Why I modified Rocrastinate Helium is after all a fork of Rocrastinate. I've always loved the library and I wished it was updated still, so I took the updating into my own hands. I've added quite a few things to the library over the base version of Rocrastinate, being: Janitor over Maid.RedrawBinding is an Enum to add autofill support.PascalCase for the entire API.Lifecycle events for Components.Store is now a metatable class instead of a function that returns a table.Components can now be redrawn on Stepped in addition to Heartbeat, RenderStep, and RenderStepTwice.Various small optimizations that can be configured using the GlobalConfiguration object.The Make function for easy Instance creation.MakeActionCreator makes it less annoying to create action creators.A port of Flipper for Helium Components, called Hydrogen, which is used for animation. The library itself may be old but it's extremely fast, and has basically all you could need for a UI library.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Method #1 - RepoToRoblox","type":1,"pageTitle":"Installation","url":"docs/Installation#method-1---repotoroblox","content":"Using Boatbomber's RepoToRoblox plugin is the easiest way to install in Studio. In the RepoToRoblox widget, enter howmanysmall as the Owner and Helium as the Repo.Click the Clone Repo button. "},{"title":"Method #2 - HttpService","type":1,"pageTitle":"Installation","url":"docs/Installation#method-2---httpservice","content":"This method uses HttpService to install Helium. In Roblox Studio, paste the following command into your command bar.Run the following command: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local HttpService = game:GetService(&quot;HttpService&quot;) local HttpEnabled = HttpService.HttpEnabled HttpService.HttpEnabled = true local function RequestAsync(RequestDictionary) return HttpService:RequestAsync(RequestDictionary) end local function GetAsync(Url, Headers) Headers[&quot;cache-control&quot;] = &quot;no-cache&quot; local Success, ResponseDictionary = pcall(RequestAsync, { Headers = Headers; Method = &quot;GET&quot;; Url = Url; }) if Success then if ResponseDictionary.Success then return ResponseDictionary.Body else return false, string.format(&quot;HTTP %d: %s&quot;, ResponseDictionary.StatusCode, ResponseDictionary.StatusMessage) end else return false, ResponseDictionary end end local function Initify(Root) local InitFile = Root:FindFirstChild(&quot;init&quot;) or Root:FindFirstChild(&quot;init.lua&quot;) or Root:FindFirstChild(&quot;init.client.lua&quot;) or Root:FindFirstChild(&quot;init.server.lua&quot;) if InitFile then InitFile.Name = Root.Name InitFile.Parent = Root.Parent for _, Child in ipairs(Root:GetChildren()) do Child.Parent = InitFile end Root:Destroy() Root = InitFile end for _, Child in ipairs(Root:GetChildren()) do Initify(Child) end return Root end local FilesList = HttpService:JSONDecode(assert(GetAsync( &quot;https://api.github.com/repos/howmanysmall/Helium/contents/src&quot;, {accept = &quot;application/vnd.github.v3+json&quot;} ))) local Helium = Instance.new(&quot;Folder&quot;) Helium.Name = &quot;Helium&quot; for _, FileData in ipairs(FilesList) do local ModuleScript = Instance.new(&quot;ModuleScript&quot;) ModuleScript.Name = tostring(string.match(FileData.name, &quot;(%w+)%.lua&quot;)) local Success, Source = GetAsync(FileData.download_url, {}) if not Success then ModuleScript.Source = string.format(&quot;-- %s&quot;, tostring(Source)) else ModuleScript.Source = tostring(Success) end ModuleScript.Parent = Helium end Helium.Parent = ReplicatedStorage Initify(Helium) HttpService.HttpEnabled = HttpEnabled "},{"title":"Method 3 - Manual","type":1,"pageTitle":"Installation","url":"docs/Installation#method-3---manual","content":"Visit the latest releaseUnder Assets, click Helium.rbxm Using Rojo? Put the file into your game directly.Using Roblox Studio? Drag the file onto the viewport. It should insert under Workspace. "},{"title":"Method 4 - Wally","type":1,"pageTitle":"Installation","url":"docs/Installation#method-4---wally","content":"Setup Wally by using wally init.Add howmanysmall/helium as a dependency. [dependencies]Helium = &quot;howmanysmall/helium@1.1.0&quot; Copy "},{"title":"Next","type":1,"pageTitle":"Installation","url":"docs/Installation#next","content":"Now, check out the API reference! "},{"title":"Why use Helium?","type":0,"sectionRef":"#","url":"docs/WhyUseHelium","content":"","keywords":""},{"title":"Performance","type":1,"pageTitle":"Why use Helium?","url":"docs/WhyUseHelium#performance","content":"This is easily Helium's strength, as it's been proven time and time again that the only faster way to do UI is to not use any library. It consistently was the top performer in the three UI Stress Test places I have. UI Stress Test 1UI Stress Test 2UI Stress Test 3 As a matter of fact, the framerate counter in UI Stress Test 3 was done with Helium, and Helium still performed better than either Fusion or Roact. "},{"title":"Lifecycle","type":1,"pageTitle":"Why use Helium?","url":"docs/WhyUseHelium#lifecycle","content":"Helium does support lifecycle events, but not in the same way or as nicely as Roact, but it's significantly better than Fusion's lack of lifecycle. The main &quot;lifecycle&quot; parts of Helium Components are four signals called Destroying, Destroyed, WillRedraw, and DidRedraw. Destroyed is called when the component is destroyed completely.Destroying is called when the component is being destroyed.DidRedraw is called right after Component:Redraw is called.WillRedraw is called right before Component:Redraw is called. I've tested the performance cost of the Redraw signals, and they're not as big of a loss. It still performs at the top. If you wish to use these, you must add them to the Helium.Component.Extend function's second parameter. "},{"title":"Native Janitor Support","type":1,"pageTitle":"Why use Helium?","url":"docs/WhyUseHelium#native-janitor-support","content":"Janitor is a top tier way to manage your Instances, connections, and whatnot. You can read more about it on my documentation for Janitor. "},{"title":"Store Class","type":1,"pageTitle":"Why use Helium?","url":"docs/WhyUseHelium#store-class","content":"Helium has a Store class similar to Redux and Rodux made just for it. It's incredibly fast and fairly simple to use. You can check out the documentation for more. "},{"title":"BaseComponent","type":0,"sectionRef":"#","url":"api/BaseComponent","content":"","keywords":""},{"title":"Properties","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#properties","content":" "},{"title":"ClassName","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#ClassName","content":"&lt;/&gt; BaseComponent.ClassName: string The Component's ClassName, which is assigned from the first argument of Component.Extend.  "},{"title":"GetReducedState","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#GetReducedState","content":"&lt;/&gt; BaseComponent.GetReducedState: () → {[string]: string} This function returns the reduced state of the component's store.  "},{"title":"Janitor","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Janitor","content":"&lt;/&gt; BaseComponent.Janitor: Janitor The component's Janitor. You can add whatever you want cleaned up on :Destroy() to this. local PrintOnDestroy = Helium.Component.Extend(&quot;PrintOnDestroy&quot;) function PrintOnDestroy:Constructor(Message: string) self.Janitor:Add(function() print(Message) end, true) end PrintOnDestroy.new(&quot;I was destroyed!&quot;):Destroy() -- Prints &quot;I was destroyed!&quot;   "},{"title":"QueueRedraw","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#QueueRedraw","content":"&lt;/&gt; BaseComponent.QueueRedraw: () → () This function queues a redraw of the component. local CoinsDisplay = Helium.Component.Extend(&quot;CoinsDisplay&quot;) function CoinsDisplay:Constructor(Parent: Instance) self.Coins = 0 self.Gui = self.Janitor:Add(Helium.Make(&quot;TextLabel&quot;, { AnchorPoint = Vector2.new(0.5, 0.5); BackgroundTransparency = 1; Position = UDim2.fromScale(0.5, 0.5); Size = UDim2.fromScale(0.5, 0.5); Font = Enum.Font.Gotham; Text = &quot;Coins: 0&quot;; TextColor3 = Color3.new(1, 1, 1); TextSize = 24; Parent = Parent; }), &quot;Destroy&quot;) end function CoinsDisplay:AddCoin() self.Coins += 1 self.QueueRedraw() -- Queues the Component to be redrawn. end CoinsDisplay.RedrawBinding = Helium.RedrawBinding.Heartbeat function CoinsDisplay:Redraw() self.Gui.Text = &quot;Coins: &quot; .. self.Coins end local MyCoinsDisplay = CoinsDisplay.new(Parent) -- Shows a TextLabel with the Text == &quot;Coins: 0&quot;. MyCoinsDisplay:AddCoin() -- Now it says &quot;Coins: 1&quot;   "},{"title":"RedrawBinding","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#RedrawBinding","content":"&lt;/&gt; BaseComponent.RedrawBinding: RedrawBinding The Component's RedrawBinding. This is used to determine when the Component's :Redraw() function is called.  "},{"title":"Reduction","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Reduction","content":"&lt;/&gt; BaseComponent.Reduction: {[string]: string}? The reduction of the store. If this exists, it'll be passed as the first argument of :Redraw(). "},{"title":"Functions","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#functions","content":" "},{"title":"new","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#new","content":"&lt;/&gt; BaseComponent.new( ...: any?-- The arguments you want to pass to the Component's constructor. ) → Component&lt;T&gt; The constructor of the Component. This version is for store-less components. local ValuePrinter = Helium.Component.Extend(&quot;ValuePrinter&quot;) function ValuePrinter:Constructor(Value: any) print(&quot;ValuePrinter:Constructor was constructed with:&quot;, Value) end ValuePrinter.new(1):Destroy() -- prints &quot;ValuePrinter:Constructor was constructed with: 1&quot;   "},{"title":"new","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#new","content":"&lt;/&gt; BaseComponent.new( Store: Store?,-- The store to use for this component. ...: any?-- The extra arguments you want to pass to the Component's constructor. ) → Component&lt;T&gt; The constructor of the Component. local ValuePrinterWithStore = Helium.Component.Extend(&quot;ValuePrinterWithStore&quot;) function ValuePrinterWithStore:Constructor(Store, Value: any) self.Store = Store print(&quot;ValuePrinterWithStore:Constructor was constructed with:&quot;, Value) end ValuePrinterWithStore.new(Helium.Store.new(function() end, {}), 1):Destroy() -- prints &quot;ValuePrinterWithStore:Constructor was constructed with: 1&quot;   "},{"title":"Constructor","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Constructor","content":"&lt;/&gt; BaseComponent:Constructor( ...: any?-- The arguments you are creating the Component with. ) → () The Component's Constructor function. This version is for store-less components. This should be overwritten. local CoinsDisplay = Helium.Component.Extend(&quot;CoinsDisplay&quot;) function CoinsDisplay:Constructor(Parent: Instance) self.Gui = self.Janitor:Add(Helium.Make(&quot;TextLabel&quot;, { AnchorPoint = Vector2.new(0.5, 0.5); BackgroundTransparency = 1; Position = UDim2.fromScale(0.5, 0.5); Size = UDim2.fromScale(0.5, 0.5); Font = Enum.Font.Gotham; Text = &quot;Coins: 1&quot;; TextColor3 = Color3.new(1, 1, 1); TextSize = 24; Parent = Parent; }), &quot;Destroy&quot;) end CoinsDisplay.new(Parent) -- Shows a TextLabel with the Text == &quot;Coins: 1&quot;.   "},{"title":"Constructor","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Constructor","content":"&lt;/&gt; BaseComponent:Constructor( Store: Store?,-- The store to use for this component. ...: any?-- The arguments you are creating the Component with. ) → () The Component's Constructor function. This should be overwritten. local CoinsDisplay = Helium.Component.Extend(&quot;CoinsDisplay&quot;) function CoinsDisplay:Constructor(Store, Parent: Instance) self.Store = Store self.Gui = self.Janitor:Add(Helium.Make(&quot;TextLabel&quot;, { AnchorPoint = Vector2.new(0.5, 0.5); BackgroundTransparency = 1; Position = UDim2.fromScale(0.5, 0.5); Size = UDim2.fromScale(0.5, 0.5); Font = Enum.Font.Gotham; Text = &quot;Coins: 0&quot;; TextColor3 = Color3.new(1, 1, 1); TextSize = 24; Parent = Parent; }), &quot;Destroy&quot;) end type CoinsReduction = {Coins: number} CoinsDisplay.Reduction = {Coins = &quot;GuiData.Coins&quot;} CoinsDisplay.RedrawBinding = Helium.RedrawBinding.Heartbeat function CoinsDisplay:Redraw(CoinsReduction: CoinsReduction) self.Gui.Text = &quot;Coins: &quot; .. CoinsReduction.Coins end local CoinsStore = Helium.Store.new(function(Action, GetState, SetState) if Action.Type == &quot;AddCoin&quot; then local Coins = GetState(&quot;GuiData&quot;, &quot;Coins&quot;) SetState(&quot;GuiData&quot;, &quot;Coins&quot;, Coins + 1) end end, {GuiData = {Coins = 0}}) local MyCoinsDisplay = CoinsDisplay.new(CoinsStore, Parent) -- Shows a TextLabel with the Text == &quot;Coins: 0&quot;. for _ = 1, 10 do task.wait(1) CoinsStore:Fire({Type = &quot;AddCoin&quot;}) end MyCoinsDisplay:Destroy()   "},{"title":"Destroy","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Destroy","content":"&lt;/&gt; BaseComponent:Destroy() → () Destroys the Component and its Janitor. warning This renders the component completely unusable. You wont' be able to call any further methods on it.  "},{"title":"Redraw","type":1,"pageTitle":"BaseComponent","url":"api/BaseComponent#Redraw","content":"&lt;/&gt; BaseComponent:Redraw( ReducedState: {[any]: any}?,-- The reduced state if BaseComponent.Reduction exists. DeltaTime: number,-- The DeltaTime since the last frame. WorldDeltaTime: number?-- The world delta time since the last frame. This only exists when RedrawBinding == Stepped. ) → () The Component's Redraw function. This can be overwritten if you need it to be. local CoinsDisplay = Helium.Component.Extend(&quot;CoinsDisplay&quot;) function CoinsDisplay:Constructor(Parent: Instance) self.Coins = 0 self.Gui = self.Janitor:Add(Helium.Make(&quot;TextLabel&quot;, { AnchorPoint = Vector2.new(0.5, 0.5); BackgroundTransparency = 1; Position = UDim2.fromScale(0.5, 0.5); Size = UDim2.fromScale(0.5, 0.5); Font = Enum.Font.Gotham; Text = &quot;Coins: 0&quot;; TextColor3 = Color3.new(1, 1, 1); TextSize = 24; Parent = Parent; }), &quot;Destroy&quot;) end function CoinsDisplay:AddCoin() self.Coins += 1 self.QueueRedraw() end CoinsDisplay.RedrawBinding = Helium.RedrawBinding.Heartbeat function CoinsDisplay:Redraw() self.Gui.Text = &quot;Coins: &quot; .. self.Coins end local MyCoinsDisplay = CoinsDisplay.new(Parent) -- Creates a TextLabel under Parent with the Text saying &quot;Coins: 0&quot; MyCoinsDisplay:AddCoin() -- Calls :Redraw() and now the TextLabel says &quot;Coins: 1&quot;  "},{"title":"Middleware","type":0,"sectionRef":"#","url":"api/Middleware","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Middleware","url":"api/Middleware#types","content":" "},{"title":"MiddlewareHandler","type":1,"pageTitle":"Middleware","url":"api/Middleware#MiddlewareHandler","content":"&lt;/&gt; type MiddlewareHandler = (NextMiddleware: (Action: BaseAction) → ()) → (Action: BaseAction) → ()  "},{"title":"Functions","type":1,"pageTitle":"Middleware","url":"api/Middleware#functions","content":" "},{"title":"InspectorMiddleware","type":1,"pageTitle":"Middleware","url":"api/Middleware#InspectorMiddleware","content":"Middleware &lt;/&gt; Middleware.InspectorMiddleware() → MiddlewareHandler-- The handler code for the middleware. Prints out the whole action being dispatched. local AwesomeAction = Helium.MakeActionCreator(&quot;AwesomeAction&quot;, function(ObjectName: string, IsAwesome: boolean) return { ObjectName = ObjectName; IsAwesome = IsAwesome; } end) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == AwesomeAction.ActionName then SetState(Action.ObjectName, Action.IsAwesome) end end, { LPlus = false; LPlusLight = false; Helium = false; }):ApplyMiddleware(Helium.InspectorMiddleware) Store:Fire(AwesomeAction(&quot;LPlus&quot;, true)) --[[ Prints: { Type = &quot;AwesomeAction&quot;; ObjectName = &quot;LPlus&quot;; IsAwesome = true; } ]]   "},{"title":"LoggerMiddleware","type":1,"pageTitle":"Middleware","url":"api/Middleware#LoggerMiddleware","content":"Middleware &lt;/&gt; Middleware.LoggerMiddleware() → MiddlewareHandler-- The handler code for the middleware. Prints out the action types of every action dispatched. local AwesomeAction = Helium.MakeActionCreator(&quot;AwesomeAction&quot;, function(ObjectName: string, IsAwesome: boolean) return { ObjectName = ObjectName; IsAwesome = IsAwesome; } end) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == AwesomeAction.ActionName then SetState(Action.ObjectName, Action.IsAwesome) end end, { LPlus = false; LPlusLight = false; Helium = false; }):ApplyMiddleware(Helium.InspectorMiddleware) Store:Fire(AwesomeAction(&quot;LPlus&quot;, true)) -- Prints: &quot;AwesomeAction&quot;   "},{"title":"SpunkMiddleware","type":1,"pageTitle":"Middleware","url":"api/Middleware#SpunkMiddleware","content":"Middleware &lt;/&gt; Middleware.SpunkMiddleware( Store: Store-- The Store of the middleware. ) → MiddlewareHandler-- The handler code for the middleware. Like ThunkMiddleware, allows functions to be dispatched. The only difference is that the functions being dispatched will be spawned immediately in a separate thread. This could be more ideal for Roblox development as opposed to JavaScript do to the lack of Promise objects. local function FetchCoins() return function(Dispatch, GetState) -- Where we would normally return an action here, we instead return a spawned thunk that defers our change in state. local Coins = ReplicatedStorage.GetCoins:InvokeServer() Dispatch({ Type = &quot;SetCoins&quot;; Value = Coins; }) end end local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == &quot;SetCoins&quot; then SetState(&quot;Coins&quot;, Action.Value) end end, InitialState):ApplyMiddleware(Helium.SpunkMiddleware) Store:Fire(FetchCoins())   "},{"title":"ThunkMiddleware","type":1,"pageTitle":"Middleware","url":"api/Middleware#ThunkMiddleware","content":"Middleware &lt;/&gt; Middleware.ThunkMiddleware( Store: Store-- The Store of the middleware. ) → MiddlewareHandler-- The handler code for the middleware. Like its Redux counterpart, thunk middleware allows functions to be dispatched as regular actions. When a function is encountered by the middleware in place of an action, that function will be intercepted and called with the arguments MyThunk(Dispatch, GetState). local function AddCoins() return function(Dispatch, GetState) Dispatch({ Type = &quot;SetCoins&quot;; Value = math.random(100); }) end end local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == &quot;SetCoins&quot; then SetState(&quot;Coins&quot;, Action.Value) end end, InitialState):ApplyMiddleware(Helium.ThunkMiddleware) Store:Fire(AddCoins())  "},{"title":"Helium","type":0,"sectionRef":"#","url":"api/Helium","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Helium","url":"api/Helium#types","content":" "},{"title":"ActionBase","type":1,"pageTitle":"Helium","url":"api/Helium#ActionBase","content":"&lt;/&gt; interface ActionBase { Type: string-- The type of action. }   "},{"title":"ActionCreatorTable","type":1,"pageTitle":"Helium","url":"api/Helium#ActionCreatorTable","content":"&lt;/&gt; interface ActionCreatorTable { ActionName: string-- The name of the action creator. Name: string-- The name of the action creator. } The ActionCreatorTable has a metatable with __call, so you can use it as a function. It returns an ActionBase.  "},{"title":"HeliumConfiguration","type":1,"pageTitle":"Helium","url":"api/Helium#HeliumConfiguration","content":"&lt;/&gt; interface HeliumConfiguration { ProfileRedraw: boolean?-- Enables debug.profilebegin in the component redraw function. RunTypeChecking: boolean?-- Enables type checking internally. SafeRedrawCheck: boolean?-- Runs an assert check when QueueRedraw is called to validate that a component's RedrawBinding is correct. UseCombineReducersV2: boolean?-- Enables using the V2 version of CombineReducers. UseSwitchStatementForQueueRedraw: boolean?-- Enables using a switch statement for QueueRedraw. This won't be checked every QueueRedraw since performance is the goal here, only when Component:Constructor is called. } This is the interface used for configuring how Helium behaves internally.  "},{"title":"RedrawBinding","type":1,"pageTitle":"Helium","url":"api/Helium#RedrawBinding","content":"Enum &lt;/&gt; interface RedrawBinding { Heartbeat: &quot;Heartbeat&quot;-- Redraw on the next Heartbeat step. RenderStep: &quot;RenderStep&quot;-- Redraw on the next RenderStep step. RenderStepTwice: &quot;RenderStepTwice&quot;-- Redraw on two RenderStep steps. Stepped: &quot;Stepped&quot;-- Redraw on the next Stepped step. } An Enum representing on which binding the Component will be redrawn on.  "},{"title":"ReducerFunction","type":1,"pageTitle":"Helium","url":"api/Helium#ReducerFunction","content":"&lt;/&gt; type ReducerFunction = ( Action: BaseAction, GetState: (...any) → any, SetState: (...any) → () ) → () This is a function for reducing actions in the store. "},{"title":"Properties","type":1,"pageTitle":"Helium","url":"api/Helium#properties","content":" "},{"title":"Children","type":1,"pageTitle":"Helium","url":"api/Helium#Children","content":"Symbol &lt;/&gt; Helium.Children: ChildrenSymbol This is a Symbol used to indicate the children for an Instance created using Helium.Make.  "},{"title":"Component","type":1,"pageTitle":"Helium","url":"api/Helium#Component","content":"Class &lt;/&gt; Helium.Component: Component This is the accessor for the Component object. local Component = Helium.Component.Extend(&quot;ComponentName&quot;)   "},{"title":"RedrawBinding","type":1,"pageTitle":"Helium","url":"api/Helium#RedrawBinding","content":"This item is read only and cannot be modified. Read Only Enums &lt;/&gt; Helium.RedrawBinding: RedrawBinding An Enumerator Enum containing all of the RedrawBindings. Case Change To keep consistent with the rest of the style of Helium, all the methods of Enumerator are PascalCase.  "},{"title":"Store","type":1,"pageTitle":"Helium","url":"api/Helium#Store","content":"Class &lt;/&gt; Helium.Store: Store This is the accessor for the Store object. local Store = Helium.Store.new(function() end, {})  "},{"title":"Functions","type":1,"pageTitle":"Helium","url":"api/Helium#functions","content":" "},{"title":"CombineReducers","type":1,"pageTitle":"Helium","url":"api/Helium#CombineReducers","content":"Utility &lt;/&gt; Helium.CombineReducers( ReducersMap: {[Key: string]: ReducerFunction}-- The reducers map ) → ReducerFunction-- A function that iterates through all the reducers and calls their respect GetState and SetState functions.   "},{"title":"CreateStore","type":1,"pageTitle":"Helium","url":"api/Helium#CreateStore","content":"Shorthand Utility &lt;/&gt; Helium.CreateStore( Reducer: ReducerFunction,-- The reducer function. InitialState: NonNil-- The initial state. ) → Store This is a shorthand for Helium.Store.new.  "},{"title":"InspectorMiddleware","type":1,"pageTitle":"Helium","url":"api/Helium#InspectorMiddleware","content":"Middleware &lt;/&gt; Helium.InspectorMiddleware() → MiddlewareHandler-- The handler code for the middleware. Prints out the whole action being dispatched. local AwesomeAction = Helium.MakeActionCreator(&quot;AwesomeAction&quot;, function(ObjectName: string, IsAwesome: boolean) return { ObjectName = ObjectName; IsAwesome = IsAwesome; } end) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == AwesomeAction.ActionName then SetState(Action.ObjectName, Action.IsAwesome) end end, { LPlus = false; LPlusLight = false; Helium = false; }):ApplyMiddleware(Helium.InspectorMiddleware) Store:Fire(AwesomeAction(&quot;LPlus&quot;, true)) --[[ Prints: { Type = &quot;AwesomeAction&quot;; ObjectName = &quot;LPlus&quot;; IsAwesome = true; } ]]   "},{"title":"LoggerMiddleware","type":1,"pageTitle":"Helium","url":"api/Helium#LoggerMiddleware","content":"Middleware &lt;/&gt; Helium.LoggerMiddleware() → MiddlewareHandler-- The handler code for the middleware. Prints out the action types of every action dispatched. local AwesomeAction = Helium.MakeActionCreator(&quot;AwesomeAction&quot;, function(ObjectName: string, IsAwesome: boolean) return { ObjectName = ObjectName; IsAwesome = IsAwesome; } end) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == AwesomeAction.ActionName then SetState(Action.ObjectName, Action.IsAwesome) end end, { LPlus = false; LPlusLight = false; Helium = false; }):ApplyMiddleware(Helium.InspectorMiddleware) Store:Fire(AwesomeAction(&quot;LPlus&quot;, true)) -- Prints: &quot;AwesomeAction&quot;   "},{"title":"Make","type":1,"pageTitle":"Helium","url":"api/Helium#Make","content":"Utility &lt;/&gt; Helium.Make( ClassName: T,-- The ClassName of the Instance you are creating. Properties: {[string]: any,[Children]?: {Instance}},-- The properties of the Instance you are creating. ) → Instance&lt;T&gt;-- The created Instance. This is a function similar to Fusion.New for creating Instances. While I don't personally suggest it, it is here if you want to use it. The Parent property is always set last if it exists in the table. local Frame: Frame = Helium.Make(&quot;Frame&quot;, { AnchorPoint = Vector2.new(0.5, 0.5); Position = UDim2.fromScale(0.5, 0.5); Size = UDim2.fromOffset(140, 40); [Helium.Children] = { Helium.Make(&quot;TextButton&quot;, { Size = UDim2.fromScale(1, 1); Text = &quot;Hello World!&quot;; Activated = function() print(&quot;Button was activated!&quot;) end; }); }; }) Frame:Destroy()   "},{"title":"MakeActionCreator","type":1,"pageTitle":"Helium","url":"api/Helium#MakeActionCreator","content":"Utility &lt;/&gt; Helium.MakeActionCreator( ActionName: string,-- The name of the Action. Function: (...any) → {[any]: any}-- The function that creates the action. ) → ActionCreatorTable-- The action creator. Action creators are helper objects that will generate actions from provided data and automatically populate the Type field. Actions are structured in a way that they always have a Type field. They will often have some other values as well. local AwesomeAction = { Type = &quot;AwesomeAction&quot;; ArgumentName = &quot;LPlus&quot;; IsAwesome = true; } You can generate an action from a function, but you must provide the Type field yourself. local function CreateAwesomeAction(ArgumentName: string, IsAwesome: boolean) return { Type = &quot;AwesomeAction&quot;; ArgumentName = ArgumentName; IsAwesome = IsAwesome; } end MakeActionCreator is similar, but it will automatically populate the Type field using the first argument of the constructor function. local CreateAwesomeAction = Helium.MakeActionCreator(&quot;AwesomeAction&quot;, function(ArgumentName: string, IsAwesome: boolean) return { ArgumentName = ArgumentName; IsAwesome = IsAwesome; } end) This can then be used in the Store reducer function. local CreateAwesomeAction = require(&quot;CreateAwesomeAction&quot;) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == CreateAwesomeAction.ActionName then SetState(Action.ArgumentName, Action.IsAwesome) end end, { LPlus = false; LPlusLight = false; Helium = false; }) Store:Fire(CreateAwesomeAction(&quot;LPlus&quot;, true)) Store:Fire(CreateAwesomeAction(&quot;Helium&quot;, true)) Store:Fire(CreateAwesomeAction(&quot;LPlusLight&quot;, false)) print(Store:InspectState()) --[[ Prints: { Helium = true; LPlus = true; LPlusLight = false; } ]]   "},{"title":"SetConfig","type":1,"pageTitle":"Helium","url":"api/Helium#SetConfig","content":"Configuration Shorthand Utility &lt;/&gt; Helium.SetConfig( ConfigurationValues: HeliumConfiguration-- The new configuration. ) → () This is a shorthand for Helium.SetGlobalConfiguration.  "},{"title":"SetConfiguration","type":1,"pageTitle":"Helium","url":"api/Helium#SetConfiguration","content":"Configuration Shorthand Utility &lt;/&gt; Helium.SetConfiguration( ConfigurationValues: HeliumConfiguration-- The new configuration. ) → () This is a shorthand for Helium.SetGlobalConfiguration.  "},{"title":"SetGlobalConfig","type":1,"pageTitle":"Helium","url":"api/Helium#SetGlobalConfig","content":"Configuration Shorthand Utility &lt;/&gt; Helium.SetGlobalConfig( ConfigurationValues: HeliumConfiguration-- The new configuration. ) → () This is a shorthand for Helium.SetGlobalConfiguration.  "},{"title":"SetGlobalConfiguration","type":1,"pageTitle":"Helium","url":"api/Helium#SetGlobalConfiguration","content":"Configuration Utility &lt;/&gt; Helium.SetGlobalConfiguration( ConfigurationValues: HeliumConfiguration-- The new configuration. ) → () This function is used to set the configuration of how Helium behaves.  "},{"title":"SpunkMiddleware","type":1,"pageTitle":"Helium","url":"api/Helium#SpunkMiddleware","content":"Middleware &lt;/&gt; Helium.SpunkMiddleware( Store: Store-- The Store of the middleware. ) → MiddlewareHandler-- The handler code for the middleware. Like ThunkMiddleware, allows functions to be dispatched. The only difference is that the functions being dispatched will be spawned immediately in a separate thread. This could be more ideal for Roblox development as opposed to JavaScript do to the lack of Promise objects. local function FetchCoins() return function(Dispatch, GetState) -- Where we would normally return an action here, we instead return a spawned thunk that defers our change in state. local Coins = ReplicatedStorage.GetCoins:InvokeServer() Dispatch({ Type = &quot;SetCoins&quot;; Value = Coins; }) end end local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == &quot;SetCoins&quot; then SetState(&quot;Coins&quot;, Action.Value) end end, InitialState):ApplyMiddleware(Helium.SpunkMiddleware) Store:Fire(FetchCoins())   "},{"title":"ThunkMiddleware","type":1,"pageTitle":"Helium","url":"api/Helium#ThunkMiddleware","content":"Middleware &lt;/&gt; Helium.ThunkMiddleware( Store: Store-- The Store of the middleware. ) → MiddlewareHandler-- The handler code for the middleware. Like its Redux counterpart, thunk middleware allows functions to be dispatched as regular actions. When a function is encountered by the middleware in place of an action, that function will be intercepted and called with the arguments MyThunk(Dispatch, GetState). local function AddCoins() return function(Dispatch, GetState) Dispatch({ Type = &quot;SetCoins&quot;; Value = math.random(100); }) end end local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == &quot;SetCoins&quot; then SetState(&quot;Coins&quot;, Action.Value) end end, InitialState):ApplyMiddleware(Helium.ThunkMiddleware) Store:Fire(AddCoins())  "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"Component","url":"api/Component#types","content":" "},{"title":"PossibleLifecycleEvents","type":1,"pageTitle":"Component","url":"api/Component#PossibleLifecycleEvents","content":"&lt;/&gt; interface PossibleLifecycleEvents { Destroyed: boolean?-- Whether or not you want to create the Destroyed event. Destroying: boolean?-- Whether or not you want to create the Destroying event. DidRedraw: boolean?-- Whether or not you want to create the DidRedraw event. WillRedraw: boolean?-- Whether or not you want to create the WillRedraw event. }  "},{"title":"Functions","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"Extend","type":1,"pageTitle":"Component","url":"api/Component#Extend","content":"&lt;/&gt; Component.Extend( ClassName: string,-- The ClassName of the component. This is used for __tostring debug stuff. LifecycleEventsToCreate: PossibleLifecycleEvents?-- The lifecycle events you want to create. ) → BaseComponent Creates a new Component object. "},{"title":"Store","type":0,"sectionRef":"#","url":"api/Store","content":"","keywords":""},{"title":"Functions","type":1,"pageTitle":"Store","url":"api/Store#functions","content":" "},{"title":"Is","type":1,"pageTitle":"Store","url":"api/Store#Is","content":"&lt;/&gt; Store.Is( Object: any-- The object to check against. ) → boolean-- Whether or not the object is a Store. Determines if the passed object is a Store. print(Helium.Store.Is(Helium.Store.new(function() end, {}))) -- true print(Helium.Store.Is({})) -- false print(Helium.Store.Is(true)) -- false   "},{"title":"new","type":1,"pageTitle":"Store","url":"api/Store#new","content":"&lt;/&gt; Store.new( Reducer: ReducerFunction,-- The reducer function. InitialState: NonNil-- The initial state. ) → Store Creates a new Store object. local Store = Helium.Store.new(function() end, {ThisIsAStore = true})   "},{"title":"ApplyMiddleware","type":1,"pageTitle":"Store","url":"api/Store#ApplyMiddleware","content":"&lt;/&gt; Store:ApplyMiddleware( Middleware: (Store: Store) → (NextDispatch: (Action: BaseAction) → ()) → (Action: BaseAction) → ()-- The middleware function you are applying. ) → Store-- The self reference for chaining these calls. Applies a Middleware to the Store. Middlware are simply functions that intercept actions upon being dispatched, and allow custom logic to be applied to them. The way middlewares intercept actions is by providing a bridge in between store.dispatch being called and the root reducer receiving those actions that were dispatched. local SetValueA = Helium.MakeActionCreator(&quot;SetValueA&quot;, function(Value) return {Value = Value} end) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == SetValueA.ActionName then SetState(&quot;ValueA&quot;, Action.Value) end end, { ValueA = &quot;A&quot;; ValueB = {ValueC = &quot;C&quot;}; }) Store:ApplyMiddleware(Helium.LoggerMiddleware):ApplyMiddleware(Helium.InspectorMiddleware) Store:Fire(SetValueA(&quot;ValueA&quot;)) --[[ Prints: { [&quot;Value&quot;] = &quot;ValueA&quot;, [&quot;Type&quot;] = &quot;SetValueA&quot; } SetValueA ]]   "},{"title":"Connect","type":1,"pageTitle":"Store","url":"api/Store#Connect","content":"&lt;/&gt; Store:Connect( StringKeyPath: string,-- The string path to run the function at. An empty string is equal to any changes made. Function: () → ()-- The function you want to run when the state is updated. ) → () → ()-- A function that disconnects the connection. Connects a function to the given string keypath. local function SetValue(Value) return {Value = Value} end local SetValueA = Helium.MakeActionCreator(&quot;SetValueA&quot;, SetValue) local SetValueC = Helium.MakeActionCreator(&quot;SetValueC&quot;, SetValue) local SetValueD = Helium.MakeActionCreator(&quot;SetValueD&quot;, SetValue) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == SetValueA.ActionName then SetState(&quot;ValueA&quot;, Action.Value) elseif Action.Type == SetValueC.ActionName then SetState(&quot;ValueB&quot;, &quot;ValueC&quot;, Action.Value) elseif Action.Type == SetValueD.ActionName then SetState(&quot;ValueD&quot;, Action.Value) end end, { ValueA = &quot;A&quot;; ValueB = {ValueC = &quot;C&quot;}; }) local Disconnect = Store:Connect(&quot;&quot;, function() print(&quot;The store was changed!&quot;, Store:GetState()) end) Store:Connect(&quot;ValueA&quot;, function() print(&quot;ValueA was changed!&quot;, Store:GetState(&quot;ValueA&quot;)) end) Store:Connect(&quot;ValueB.ValueC&quot;, function() print(&quot;ValueB.ValueC was changed!&quot;, Store:GetState(&quot;ValueB&quot;, &quot;ValueC&quot;)) end) Store:Fire(SetValueD(&quot;ValueD&quot;)) --[[ Prints: The store was changed! { [&quot;ValueA&quot;] = &quot;A&quot;, [&quot;ValueB&quot;] = { [&quot;ValueC&quot;] = &quot;C&quot; }, [&quot;ValueD&quot;] = &quot;ValueD&quot; } ]] Disconnect() Store:Fire(SetValueA(&quot;ValueA&quot;)) -- Prints: ValueA was changed! ValueA Store:Fire(SetValueC(&quot;ValueC&quot;)) -- Prints: ValueB.ValueC was changed! ValueC   "},{"title":"Dispatch","type":1,"pageTitle":"Store","url":"api/Store#Dispatch","content":"&lt;/&gt; Store:Dispatch( Action: BaseAction-- The Action you are dispatching. ) → () Dispatches an Action to the Store. local DispatchAction = Helium.MakeActionCreator(&quot;DispatchAction&quot;, function(Value) return { Value = Value; } end) Store:Dispatch(DispatchAction(&quot;Value&quot;)) Store:Dispatch({ Type = &quot;AwesomeAction&quot;; AwesomeValue = true; })   "},{"title":"Fire","type":1,"pageTitle":"Store","url":"api/Store#Fire","content":"&lt;/&gt; Store:Fire( Action: BaseAction-- The Action you are dispatching. ) → () Dispatches an Action to the Store. local DispatchAction = Helium.MakeActionCreator(&quot;DispatchAction&quot;, function(Value) return { Value = Value; } end) Store:Fire(DispatchAction(&quot;Value&quot;)) Store:Fire({ Type = &quot;AwesomeAction&quot;; AwesomeValue = true; })   "},{"title":"GetState","type":1,"pageTitle":"Store","url":"api/Store#GetState","content":"&lt;/&gt; Store:GetState( ...: string?-- The string path you want to get. ) → T-- The current Store state. Gets the current Store state. If the value returned is a table, it is deep copied to prevent You can optionally provide a path. local Store = Helium.Store.new(function() end, { ValueA = &quot;A&quot;; ValueB = {ValueC = &quot;C&quot;}; }) print(Store:GetState()) -- The state. print(Store:GetState(&quot;ValueA&quot;)) -- &quot;A&quot; print(Store:GetState(&quot;ValueB&quot;, &quot;ValueC&quot;)) -- &quot;C&quot;   "},{"title":"InspectState","type":1,"pageTitle":"Store","url":"api/Store#InspectState","content":"&lt;/&gt; Store:InspectState() → string-- The string representation of the Store's current state. Returns a string representation of the Store's current state. This is useful for debugging things. local Store = Helium.Store.new(function() end, { ValueA = &quot;A&quot;; ValueB = {ValueC = &quot;C&quot;}; }) print(Store:InspectState()) --[[ Prints: { [&quot;ValueA&quot;] = &quot;A&quot;, [&quot;ValueB&quot;] = { [&quot;ValueC&quot;] = &quot;C&quot; } } ]]   "},{"title":"SetState","type":1,"pageTitle":"Store","url":"api/Store#SetState","content":"&lt;/&gt; Store:SetState( ...: string?,-- The path of the state to set. Value: any-- The value you are setting. This is always required, think of it as setting a Url -&gt; example.com/path/to/value == &quot;path&quot;, &quot;to&quot;, &quot;value&quot; ) → () Sets the current Store state. The varargs are the string paths you want to set the state of. info The path is totally optional and skipping it will just result in you editing the root of the state table. warning SetState overwrites the table, so if you want to preserve the original table, you should be using actions and the reducer function. local Store = Helium.Store.new(function() end, { ValueA = &quot;A&quot;; }) print(Store:GetState(&quot;ValueA&quot;)) -- &quot;A&quot; Store:SetState(&quot;ValueA&quot;, &quot;ValueA&quot;) print(Store:GetState(&quot;ValueA&quot;)) -- &quot;ValueA&quot; local Store = Helium.Store.new(function() end, { ValueB = {ValueC = &quot;C&quot;}; }) print(Store:GetState(&quot;ValueB&quot;, &quot;ValueC&quot;)) -- &quot;C&quot; Store:SetState(&quot;ValueB&quot;, &quot;ValueC&quot;, 3) print(Store:GetState(&quot;ValueB&quot;, &quot;ValueC&quot;)) -- &quot;3&quot;   "},{"title":"Subscribe","type":1,"pageTitle":"Store","url":"api/Store#Subscribe","content":"&lt;/&gt; Store:Subscribe( StringKeyPath: string,-- The string path to run the function at. An empty string is equal to any changes made. Function: () → ()-- The function you want to run when the state is updated. ) → () → ()-- A function that disconnects the connection. Connects a function to the given string keypath. local function SetValue(Value) return {Value = Value} end local SetValueA = Helium.MakeActionCreator(&quot;SetValueA&quot;, SetValue) local SetValueC = Helium.MakeActionCreator(&quot;SetValueC&quot;, SetValue) local SetValueD = Helium.MakeActionCreator(&quot;SetValueD&quot;, SetValue) local Store = Helium.Store.new(function(Action, _, SetState) if Action.Type == SetValueA.ActionName then SetState(&quot;ValueA&quot;, Action.Value) elseif Action.Type == SetValueC.ActionName then SetState(&quot;ValueB&quot;, &quot;ValueC&quot;, Action.Value) elseif Action.Type == SetValueD.ActionName then SetState(&quot;ValueD&quot;, Action.Value) end end, { ValueA = &quot;A&quot;; ValueB = {ValueC = &quot;C&quot;}; }) local Disconnect = Store:Subscribe(&quot;&quot;, function() print(&quot;The store was changed!&quot;, Store:GetState()) end) Store:Subscribe(&quot;ValueA&quot;, function() print(&quot;ValueA was changed!&quot;, Store:GetState(&quot;ValueA&quot;)) end) Store:Subscribe(&quot;ValueB.ValueC&quot;, function() print(&quot;ValueB.ValueC was changed!&quot;, Store:GetState(&quot;ValueB&quot;, &quot;ValueC&quot;)) end) Store:Dispatch(SetValueD(&quot;ValueD&quot;)) --[[ Prints: The store was changed! { [&quot;ValueA&quot;] = &quot;A&quot;, [&quot;ValueB&quot;] = { [&quot;ValueC&quot;] = &quot;C&quot; }, [&quot;ValueD&quot;] = &quot;ValueD&quot; } ]] Disconnect() Store:Dispatch(SetValueA(&quot;ValueA&quot;)) -- Prints: ValueA was changed! ValueA Store:Dispatch(SetValueC(&quot;ValueC&quot;)) -- Prints: ValueB.ValueC was changed! ValueC  "}]